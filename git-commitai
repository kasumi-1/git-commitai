#!/usr/bin/env python3

import os
import sys
import json
import subprocess
import tempfile
import argparse
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError

def get_env_config():
    """Get configuration from environment variables."""
    config = {
        'api_key': os.environ.get('GIT_COMMIT_AI_KEY'),
        'api_url': os.environ.get('GIT_COMMIT_AI_URL', 'https://api.openai.com/v1/chat/completions'),
        'model': os.environ.get('GIT_COMMIT_AI_MODEL', 'gpt-4o')
    }
    
    if not config['api_key']:
        print("Error: GIT_COMMIT_AI_KEY environment variable is not set")
        print()
        print("Please set up your API credentials:")
        print("  export GIT_COMMIT_AI_KEY='your-api-key'")
        print("  export GIT_COMMIT_AI_URL='https://api.openai.com/v1/chat/completions' # or your provider's URL")
        print("  export GIT_COMMIT_AI_MODEL='gpt-4o' # or your preferred model")
        sys.exit(1)
    
    return config

def run_command(cmd, check=True):
    """Run a shell command and return output."""
    try:
        result = subprocess.run(
            cmd, 
            shell=True, 
            capture_output=True, 
            text=True, 
            check=check
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        if check:
            raise
        return e.stdout.strip() if e.stdout else ""

def check_staged_changes():
    """Check if there are staged changes and provide git-like output if not."""
    try:
        result = subprocess.run(
            ['git', 'diff', '--cached', '--quiet'],
            capture_output=True
        )
        if result.returncode == 0:
            # No staged changes - mimic git commit output
            show_git_status()
            return False
        return True
    except subprocess.CalledProcessError:
        return False

def show_git_status():
    """Show git status output similar to what 'git commit' shows."""
    # Get branch name
    try:
        branch = run_command('git branch --show-current')
        if not branch:  # detached HEAD state
            branch = run_command('git rev-parse --short HEAD')
            print(f"HEAD detached at {branch}")
        else:
            print(f"On branch {branch}")
    except:
        print("On branch master")
    
    # Check if this is initial commit
    try:
        run_command('git rev-parse HEAD', check=True)
    except:
        print("\nInitial commit\n")
    
    # Get untracked and modified files
    try:
        status_output = run_command('git status --porcelain')
        
        untracked = []
        modified = []
        deleted = []
        
        for line in status_output.split('\n'):
            if not line:
                continue
            status = line[:2]
            filename = line[3:]
            
            if status == '??':
                untracked.append(filename)
            elif 'M' in status and status[0] != 'M':  # Modified but not staged
                modified.append(filename)
            elif 'D' in status and status[0] != 'D':  # Deleted but not staged
                deleted.append(filename)
        
        # Show unstaged changes
        changes_shown = False
        if modified or deleted:
            print("Changes not staged for commit:")
            print('  (use "git add <file>..." to update what will be committed)')
            print('  (use "git restore <file>..." to discard changes in working directory)')
            for f in modified:
                print(f"\tmodified:   {f}")
            for f in deleted:
                print(f"\tdeleted:    {f}")
            print()
            changes_shown = True
        
        # Show untracked files
        if untracked:
            print("Untracked files:")
            print('  (use "git add <file>..." to include in what will be committed)')
            for f in untracked:
                print(f"\t{f}")
            print()
            changes_shown = True
        
        # Final message
        if not changes_shown:
            print("nothing to commit, working tree clean")
        elif untracked and not modified and not deleted:
            print("nothing added to commit but untracked files present (use \"git add\" to track)")
        elif modified or deleted:
            print("no changes added to commit (use \"git add\" and/or \"git commit -a\")")
    except Exception as e:
        # Fallback to simple message if something goes wrong
        print("No changes staged for commit")

def get_staged_files():
    """Get list of staged files with their staged contents."""
    files_output = run_command('git diff --cached --name-only')
    if not files_output:
        return ""
    
    all_files = []
    for filename in files_output.split('\n'):
        if filename:
            try:
                # Get the staged content of the file (what's in the index)
                # :filename syntax gets the staged version
                staged_content = run_command(f'git show :{filename}', check=False)
                if staged_content or staged_content == "":  # Include empty files too
                    all_files.append(f"{filename}\n```\n{staged_content}\n```\n")
            except Exception:
                # File might be newly added or binary, skip it
                continue
    
    return '\n'.join(all_files)

def get_git_diff():
    """Get the git diff of staged changes."""
    diff = run_command('git diff --cached')
    return f"```\n{diff}\n```"

def get_git_editor():
    """Get the configured git editor."""
    # Check environment variables first
    editor = os.environ.get('GIT_EDITOR')
    if editor:
        return editor
    
    editor = os.environ.get('EDITOR')
    if editor:
        return editor
    
    # Try git config
    try:
        editor = run_command('git config --get core.editor', check=False)
        if editor:
            return editor
    except:
        pass
    
    # Default fallback
    return 'vi'

def get_current_branch():
    """Get current git branch name."""
    try:
        return run_command('git branch --show-current')
    except:
        return 'unknown'

def get_git_dir():
    """Get the .git directory path."""
    # This should never fail since we check in main(), but just in case
    return run_command('git rev-parse --git-dir')

def make_api_request(config, message):
    """Make API request to generate commit message."""
    payload = {
        'model': config['model'],
        'messages': [
            {
                'role': 'user',
                'content': message
            }
        ]
    }
    
    req = Request(
        config['api_url'],
        data=json.dumps(payload).encode('utf-8'),
        headers={
            'Content-Type': 'application/json',
            'Authorization': f"Bearer {config['api_key']}"
        }
    )
    
    try:
        with urlopen(req) as response:
            data = json.loads(response.read().decode('utf-8'))
            return data['choices'][0]['message']['content']
    except (URLError, HTTPError) as e:
        print(f"Error: Failed to make API request: {e}")
        sys.exit(1)
    except (KeyError, IndexError, json.JSONDecodeError) as e:
        print(f"Error: Failed to parse API response: {e}")
        sys.exit(1)

def create_commit_message_file(git_dir, commit_message):
    """Create the commit message file with git template."""
    commit_file = os.path.join(git_dir, 'COMMIT_EDITMSG')
    
    with open(commit_file, 'w') as f:
        f.write(commit_message)
        f.write('\n\n')
        f.write('# Please enter the commit message for your changes. Lines starting\n')
        f.write("# with '#' will be ignored, and an empty message aborts the commit.\n")
        f.write('#\n')
        f.write(f'# On branch {get_current_branch()}\n')
        f.write('#\n')
        f.write('# Changes to be committed:\n')
        
        # Get staged files status
        status = run_command('git diff --cached --name-status')
        for line in status.split('\n'):
            if line:
                f.write(f'# {line}\n')
        f.write('#\n')
    
    return commit_file

def open_editor(filepath, editor):
    """Open file in editor and wait for it to close."""
    try:
        subprocess.run([editor, filepath])
    except Exception:
        print(f"Error: Failed to open editor: {editor}")
        sys.exit(1)

def is_commit_message_empty(filepath):
    """Check if commit message is empty (ignoring comments)."""
    try:
        with open(filepath, 'r') as f:
            for line in f:
                # Skip comments and empty lines
                line = line.strip()
                if line and not line.startswith('#'):
                    return False
        return True
    except:
        return True

def main():
    parser = argparse.ArgumentParser(description='Generate AI-powered git commit messages')
    parser.add_argument('-m', '--message', help='Additional context about the commit')
    args = parser.parse_args()
    
    # Check if in a git repository first
    try:
        subprocess.run(['git', 'rev-parse', '--git-dir'], 
                      capture_output=True, check=True)
    except subprocess.CalledProcessError:
        print("fatal: not a git repository (or any of the parent directories): .git")
        sys.exit(128)  # Git's standard exit code for this error
    
    # Check for staged changes
    if not check_staged_changes():
        sys.exit(1)
    
    # Get configuration
    config = get_env_config()
    
    # Build the prompt
    prompt = """You are a git commit message generator. Generate ONLY the commit message without any additional text, explanations, or prefixes like 'Here's the commit message' or 'Sure'.

The first line should be a concise summary (50 characters or less if possible).
If needed, add a blank line and then a more detailed explanation.
Focus on WHAT changed and WHY it changed.
Do not include any conversational text, only the commit message itself."""
    
    if args.message:
        prompt += f"\n\nUser context about this commit: {args.message}"
    
    # Get git information
    git_diff = get_git_diff()
    all_files = get_staged_files()
    
    prompt += f"""

Here is the git diff:

{git_diff}

Here are all of the files for context:

{all_files}"""
    
    # Make API request
    commit_message = make_api_request(config, prompt)
    
    # Get git directory
    git_dir = get_git_dir()
    
    # Create commit message file
    commit_file = create_commit_message_file(git_dir, commit_message)
    
    # Get modification time before editing
    mtime_before = os.path.getmtime(commit_file)
    
    # Open editor
    editor = get_git_editor()
    open_editor(commit_file, editor)
    
    # Check if file was modified (saved)
    mtime_after = os.path.getmtime(commit_file)
    
    if mtime_before == mtime_after:
        # File wasn't saved (user did :q! or equivalent)
        print("Aborting commit due to empty commit message.")
        sys.exit(1)
    
    # Check if message is empty
    if is_commit_message_empty(commit_file):
        print("Aborting commit due to empty commit message.")
        sys.exit(1)
    
    # Perform the commit
    try:
        subprocess.run(['git', 'commit', '-F', commit_file], check=True)
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)

if __name__ == '__main__':
    main()
